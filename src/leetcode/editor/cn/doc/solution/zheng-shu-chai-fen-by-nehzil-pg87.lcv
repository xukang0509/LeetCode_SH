**动态规划思路分析**
对于的正整数 $n$，当 $n ≥ 2$ 时，可以拆分成至少两个正整数的和。令 $k$ 是拆分出的第一个正整数，则剩下的部分是 $n−k$，$n−k$ 可以不继续拆分，或者继续拆分成至少两个正整数的和（一个问题可以分解为相似的子问题因此想到动态规划）。由于每个正整数对应的最大乘积取决于比它小的正整数对应的最大乘积，因此可以使用动态规划求解。
**算法实现步骤**
- **确定dp数组以及下标的含义**
  - $dp[i]$ 表示将正整数 $i$ 拆分成至少两个正整数的和之后，这些正整数的最大乘积
- **确定状态转移方程**
  - 当 $i ≥ 2$ 时，假设对正整数 $i$ 拆分出的第一个正整数是 $j（1≤j<i）$，则有以下两种方案：
    - 将 $i$ 拆分成 $j$ 和 $i-j$ 的和，且 $i−j$ 不再拆分成多个正整数，此时的乘积是 $j×(i−j)$ ；
    - 将 $i$ 拆分成 $j$ 和 $i−j$ 的和，且 $i−j$ 继续拆分成多个正整数，此时的乘积是 $j×dp[i−j]$ 。
    - 因此，当 $j$ 固定时，有 $dp[i]=max(j×(i−j),j×dp[i−j])$。由于 $j$ 的取值范围是 $1$ 到 $i−1$ ，需要遍历所有的 $j$ 得到 $dp[i]$的
- **初始化状态**
  - $0$ 不是正整数，$1$ 是最小的正整数，$0$ 和 $1$ 都不能拆分，因此 $dp[0]=dp[1]=0$。
- **遍历顺序**
  - 由状态转移方程知道 $dp[i]$ 是从 $j×(i−j)$ 和 $j×dp[i−j]$  且 $j$ 的取值范围是 $1$ 到 $i−1$ ，需要遍历所有的 $j$ 得到 $dp[i]$ 所以从前往后遍历。
- **返回值**
  - 最终得到 $dp[n]$ 的值即为将正整数 $n$ 拆分成至少两个正整数的和之后，这些正整数的最大乘积。

* []

```C++
class Solution {
public:
    /**
     * 1. 确定dp数组下标含义 分拆数字i，可以得到的最大乘积为dp[i];
     * 2. 递推公式 dp[i] = max(dp[i], (i - j) * j, dp[i - j] * j);
     * 3. 初始化 dp[2] = 1;
     * 4. 遍历顺序 从前向后遍历就可以;
     * 5. 推导结果;
     */
    int integerBreak(int n) {
        /* 定义dp数组 */
        vector<int> dp(n + 1);
        /* dp数组初始化 */
        dp[2] = 1;
        /* 从前向后遍历 */
        for (int i = 3; i <= n ; i++) {
            /* j遍历到小于i的值 */
            for (int j = 1; j < i - 1; j++) {
                dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
            }
        }
        return dp[n];
    }
};
```

**复杂度分析:**
- 时间复杂度：$O(n^2)$，其中 $n$ 是给定的正整数。
- 空间复杂度：$O(n)$，其中 $n$ 是给定的正整数。

